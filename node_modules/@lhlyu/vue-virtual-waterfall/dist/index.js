var U = Object.defineProperty;
var M = Object.getOwnPropertySymbols;
var j = Object.prototype.hasOwnProperty, H = Object.prototype.propertyIsEnumerable;
var T = (e, t, o) => t in e ? U(e, t, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[t] = o, V = (e, t) => {
  for (var o in t || (t = {}))
    j.call(t, o) && T(e, o, t[o]);
  if (M)
    for (var o of M(t))
      H.call(t, o) && T(e, o, t[o]);
  return e;
};
var k = (e, t) => {
  var o = {};
  for (var r in e)
    j.call(e, r) && t.indexOf(r) < 0 && (o[r] = e[r]);
  if (e != null && M)
    for (var r of M(e))
      t.indexOf(r) < 0 && H.call(e, r) && (o[r] = e[r]);
  return o;
};
import { onMounted as I, nextTick as J, getCurrentScope as Q, onScopeDispose as X, unref as Y, getCurrentInstance as P, ref as w, watch as W, computed as x, defineComponent as Z, shallowRef as ee, watchEffect as te, openBlock as z, createElementBlock as _, normalizeStyle as F, Fragment as ne, renderList as oe, renderSlot as ie } from "vue";
function L(e) {
  return Q() ? (X(e), !0) : !1;
}
function O(e) {
  return typeof e == "function" ? e() : Y(e);
}
const ue = typeof window != "undefined" && typeof document != "undefined";
typeof WorkerGlobalScope != "undefined" && globalThis instanceof WorkerGlobalScope;
const re = (e) => e != null, se = Object.prototype.toString, le = (e) => se.call(e) === "[object Object]", ce = () => {
};
function ae(e) {
  return P();
}
function D(e, t = !0, o) {
  ae() ? I(e, o) : t ? e() : J(e);
}
function y(e) {
  var t;
  const o = O(e);
  return (t = o == null ? void 0 : o.$el) != null ? t : o;
}
const R = ue ? window : void 0;
function N(...e) {
  let t, o, r, m;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([o, r, m] = e, t = R) : [t, o, r, m] = e, !t)
    return ce;
  Array.isArray(o) || (o = [o]), Array.isArray(r) || (r = [r]);
  const a = [], l = () => {
    a.forEach((d) => d()), a.length = 0;
  }, c = (d, i, n, u) => (d.addEventListener(i, n, u), () => d.removeEventListener(i, n, u)), v = W(
    () => [y(t), O(m)],
    ([d, i]) => {
      if (l(), !d)
        return;
      const n = le(i) ? V({}, i) : i;
      a.push(
        ...o.flatMap((u) => r.map((s) => c(d, u, s, n)))
      );
    },
    { immediate: !0, flush: "post" }
  ), f = () => {
    v(), l();
  };
  return L(f), f;
}
function fe() {
  const e = w(!1), t = P();
  return t && I(() => {
    e.value = !0;
  }, t), e;
}
function K(e) {
  const t = fe();
  return x(() => (t.value, !!e()));
}
function de(e, t, o = {}) {
  const n = o, { window: r = R } = n, m = k(n, ["window"]);
  let a;
  const l = K(() => r && "MutationObserver" in r), c = () => {
    a && (a.disconnect(), a = void 0);
  }, v = x(() => {
    const u = O(e), s = (Array.isArray(u) ? u : [u]).map(y).filter(re);
    return new Set(s);
  }), f = W(
    () => v.value,
    (u) => {
      c(), l.value && u.size && (a = new MutationObserver(t), u.forEach((s) => a.observe(s, m)));
    },
    { immediate: !0, flush: "post" }
  ), d = () => a == null ? void 0 : a.takeRecords(), i = () => {
    f(), c();
  };
  return L(i), {
    isSupported: l,
    stop: i,
    takeRecords: d
  };
}
function q(e, t, o = {}) {
  const i = o, { window: r = R } = i, m = k(i, ["window"]);
  let a;
  const l = K(() => r && "ResizeObserver" in r), c = () => {
    a && (a.disconnect(), a = void 0);
  }, v = x(() => {
    const n = O(e);
    return Array.isArray(n) ? n.map((u) => y(u)) : [y(n)];
  }), f = W(
    v,
    (n) => {
      if (c(), l.value && r) {
        a = new ResizeObserver(t);
        for (const u of n)
          u && a.observe(u, m);
      }
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    c(), f();
  };
  return L(d), {
    isSupported: l,
    stop: d
  };
}
function pe(e, t = {}) {
  const {
    reset: o = !0,
    windowResize: r = !0,
    windowScroll: m = !0,
    immediate: a = !0,
    updateTiming: l = "sync"
  } = t, c = w(0), v = w(0), f = w(0), d = w(0), i = w(0), n = w(0), u = w(0), s = w(0);
  function g() {
    const b = y(e);
    if (!b) {
      o && (c.value = 0, v.value = 0, f.value = 0, d.value = 0, i.value = 0, n.value = 0, u.value = 0, s.value = 0);
      return;
    }
    const h = b.getBoundingClientRect();
    c.value = h.height, v.value = h.bottom, f.value = h.left, d.value = h.right, i.value = h.top, n.value = h.width, u.value = h.x, s.value = h.y;
  }
  function p() {
    l === "sync" ? g() : l === "next-frame" && requestAnimationFrame(() => g());
  }
  return q(e, p), W(() => y(e), (b) => !b && p()), de(e, p, {
    attributeFilter: ["style", "class"]
  }), m && N("scroll", p, { capture: !0, passive: !0 }), r && N("resize", p, { passive: !0 }), D(() => {
    a && p();
  }), {
    height: c,
    bottom: v,
    left: f,
    right: d,
    top: i,
    width: n,
    x: u,
    y: s,
    update: p
  };
}
function ve(e, t = { width: 0, height: 0 }, o = {}) {
  const { window: r = R, box: m = "content-box" } = o, a = x(() => {
    var i, n;
    return (n = (i = y(e)) == null ? void 0 : i.namespaceURI) == null ? void 0 : n.includes("svg");
  }), l = w(t.width), c = w(t.height), { stop: v } = q(
    e,
    ([i]) => {
      const n = m === "border-box" ? i.borderBoxSize : m === "content-box" ? i.contentBoxSize : i.devicePixelContentBoxSize;
      if (r && a.value) {
        const u = y(e);
        if (u) {
          const s = u.getBoundingClientRect();
          l.value = s.width, c.value = s.height;
        }
      } else if (n) {
        const u = Array.isArray(n) ? n : [n];
        l.value = u.reduce((s, { inlineSize: g }) => s + g, 0), c.value = u.reduce((s, { blockSize: g }) => s + g, 0);
      } else
        l.value = i.contentRect.width, c.value = i.contentRect.height;
    },
    o
  );
  D(() => {
    const i = y(e);
    i && (l.value = "offsetWidth" in i ? i.offsetWidth : t.width, c.value = "offsetHeight" in i ? i.offsetHeight : t.height);
  });
  const f = W(
    () => y(e),
    (i) => {
      l.value = i ? t.width : 0, c.value = i ? t.height : 0;
    }
  );
  function d() {
    v(), f();
  }
  return {
    width: l,
    height: c,
    stop: d
  };
}
const he = ["data-index"], G = /* @__PURE__ */ Z({
  name: "VirtualWaterfall",
  __name: "virtual-waterfall",
  props: {
    virtual: { type: Boolean, default: !0 },
    rowKey: { default: "id" },
    gap: { default: 15 },
    padding: { default: 15 },
    preloadScreenCount: { default: () => [0, 0] },
    itemMinWidth: { default: 220 },
    maxColumnCount: { default: 10 },
    minColumnCount: { default: 2 },
    items: { default: () => [] },
    calcItemHeight: { type: Function, default: (e, t) => 250 }
  },
  setup(e) {
    const t = e, o = w(), { width: r } = ve(o), { top: m } = pe(o);
    I(() => {
      r.value === 0 && (r.value = Number.parseInt(window.getComputedStyle(o.value).width));
    });
    function a(n) {
      return Object.prototype.toString.call(n) === "[object Number]";
    }
    const l = x(() => {
      if (!r.value)
        return 0;
      const n = r.value;
      if (n >= t.itemMinWidth * 2) {
        const u = Math.floor(n / t.itemMinWidth);
        return t.maxColumnCount && u > t.maxColumnCount ? t.maxColumnCount : u;
      }
      return t.minColumnCount;
    }), c = w(new Array(l.value).fill(0)), v = x(() => {
      if (!r.value || l.value <= 0)
        return 0;
      const n = (l.value - 1) * t.gap;
      return Math.ceil((r.value - n) / l.value);
    }), f = ee([]);
    te(() => {
      if (!l.value) {
        f.value = [];
        return;
      }
      const n = t.items.length, u = new Array(n);
      let s = 0;
      const g = f.value.length && n > f.value.length;
      g ? s = f.value.length : c.value = new Array(l.value).fill(0);
      for (let p = 0; p < n; p++) {
        if (g && p < s) {
          u[p] = f.value[p];
          continue;
        }
        const b = i(), h = t.calcItemHeight(t.items[p], v.value), C = c.value[b], A = (v.value + t.gap) * b, S = {
          index: p,
          item: t.items[p],
          column: b,
          top: C,
          left: A,
          bottom: C + h,
          height: h
        };
        c.value[b] += h + t.gap, u[p] = S;
      }
      f.value = u;
    });
    const d = x(() => {
      const n = f.value.length;
      if (!n)
        return [];
      if (!t.virtual)
        return f.value;
      const u = o.value.parentElement.offsetTop, s = -m.value + u, [g, p] = t.preloadScreenCount, b = o.value.parentElement.clientHeight, h = s - g * b, C = s + (p + 1) * b, A = [];
      for (let S = 0; S < n; S++) {
        const E = f.value[S], B = E.top, $ = E.bottom;
        (B >= h && B <= C || $ >= h && $ <= C || B < h && $ > C) && A.push(E);
      }
      return A;
    }), i = () => c.value.indexOf(Math.min(...c.value));
    return (n, u) => (z(), _("div", {
      ref_key: "content",
      ref: o,
      style: F({
        position: "relative",
        willChange: "height",
        height: `${Math.max(...c.value)}px`,
        padding: `${a(n.padding) ? n.padding + "px" : n.padding}`
      })
    }, [
      (z(!0), _(ne, null, oe(d.value, (s) => {
        var g;
        return z(), _("div", {
          key: (g = s.item[n.rowKey]) != null ? g : s.index,
          style: F({
            position: "absolute",
            contentVisibility: "auto",
            width: `${v.value}px`,
            height: `${s.height}px`,
            transform: `translate(${s.left}px, ${s.top}px)`,
            containIntrinsicSize: `${v.value}px ${s.height}px`
          }),
          "data-index": s.index
        }, [
          ie(n.$slots, "default", {
            item: s.item,
            index: s.index
          })
        ], 12, he);
      }), 128))
    ], 4));
  }
}), we = {
  install(e) {
    e.component(G.name, G);
  }
};
export {
  G as VirtualWaterfall,
  we as default
};
