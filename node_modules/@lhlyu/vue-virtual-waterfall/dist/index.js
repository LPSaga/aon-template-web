var q = Object.defineProperty;
var A = Object.getOwnPropertySymbols;
var j = Object.prototype.hasOwnProperty, H = Object.prototype.propertyIsEnumerable;
var T = (e, t, n) => t in e ? q(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, N = (e, t) => {
  for (var n in t || (t = {}))
    j.call(t, n) && T(e, n, t[n]);
  if (A)
    for (var n of A(t))
      H.call(t, n) && T(e, n, t[n]);
  return e;
};
var B = (e, t) => {
  var n = {};
  for (var i in e)
    j.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
  if (e != null && A)
    for (var i of A(e))
      t.indexOf(i) < 0 && H.call(e, i) && (n[i] = e[i]);
  return n;
};
import { onMounted as I, nextTick as J, getCurrentScope as Q, onScopeDispose as X, unref as Y, getCurrentInstance as P, ref as g, watch as W, computed as x, defineComponent as Z, useSlots as ee, watchEffect as te, openBlock as k, createElementBlock as z, normalizeStyle as F, Fragment as ne, renderList as oe, renderSlot as ie } from "vue";
function L(e) {
  return Q() ? (X(e), !0) : !1;
}
function _(e) {
  return typeof e == "function" ? e() : Y(e);
}
const ue = typeof window != "undefined" && typeof document != "undefined";
typeof WorkerGlobalScope != "undefined" && globalThis instanceof WorkerGlobalScope;
const se = (e) => e != null, re = Object.prototype.toString, le = (e) => re.call(e) === "[object Object]", ce = () => {
};
function ae(e) {
  return e || P();
}
function D(e, t = !0, n) {
  ae() ? I(e, n) : t ? e() : J(e);
}
function b(e) {
  var t;
  const n = _(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const O = ue ? window : void 0;
function V(...e) {
  let t, n, i, m;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, i, m] = e, t = O) : [t, n, i, m] = e, !t)
    return ce;
  Array.isArray(n) || (n = [n]), Array.isArray(i) || (i = [i]);
  const a = [], l = () => {
    a.forEach((d) => d()), a.length = 0;
  }, c = (d, u, o, r) => (d.addEventListener(u, o, r), () => d.removeEventListener(u, o, r)), v = W(
    () => [b(t), _(m)],
    ([d, u]) => {
      if (l(), !d)
        return;
      const o = le(u) ? N({}, u) : u;
      a.push(
        ...n.flatMap((r) => i.map((s) => c(d, r, s, o)))
      );
    },
    { immediate: !0, flush: "post" }
  ), f = () => {
    v(), l();
  };
  return L(f), f;
}
function fe() {
  const e = g(!1), t = P();
  return t && I(() => {
    e.value = !0;
  }, t), e;
}
function K(e) {
  const t = fe();
  return x(() => (t.value, !!e()));
}
function de(e, t, n = {}) {
  const o = n, { window: i = O } = o, m = B(o, ["window"]);
  let a;
  const l = K(() => i && "MutationObserver" in i), c = () => {
    a && (a.disconnect(), a = void 0);
  }, v = x(() => {
    const r = _(e), s = (Array.isArray(r) ? r : [r]).map(b).filter(se);
    return new Set(s);
  }), f = W(
    () => v.value,
    (r) => {
      c(), l.value && i && r.size && (a = new MutationObserver(t), r.forEach((s) => a.observe(s, m)));
    },
    { immediate: !0, flush: "post" }
  ), d = () => a == null ? void 0 : a.takeRecords(), u = () => {
    c(), f();
  };
  return L(u), {
    isSupported: l,
    stop: u,
    takeRecords: d
  };
}
function U(e, t, n = {}) {
  const u = n, { window: i = O } = u, m = B(u, ["window"]);
  let a;
  const l = K(() => i && "ResizeObserver" in i), c = () => {
    a && (a.disconnect(), a = void 0);
  }, v = x(() => Array.isArray(e) ? e.map((o) => b(o)) : [b(e)]), f = W(
    v,
    (o) => {
      if (c(), l.value && i) {
        a = new ResizeObserver(t);
        for (const r of o)
          r && a.observe(r, m);
      }
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    c(), f();
  };
  return L(d), {
    isSupported: l,
    stop: d
  };
}
function pe(e, t = {}) {
  const {
    reset: n = !0,
    windowResize: i = !0,
    windowScroll: m = !0,
    immediate: a = !0
  } = t, l = g(0), c = g(0), v = g(0), f = g(0), d = g(0), u = g(0), o = g(0), r = g(0);
  function s() {
    const h = b(e);
    if (!h) {
      n && (l.value = 0, c.value = 0, v.value = 0, f.value = 0, d.value = 0, u.value = 0, o.value = 0, r.value = 0);
      return;
    }
    const p = h.getBoundingClientRect();
    l.value = p.height, c.value = p.bottom, v.value = p.left, f.value = p.right, d.value = p.top, u.value = p.width, o.value = p.x, r.value = p.y;
  }
  return U(e, s), W(() => b(e), (h) => !h && s()), de(e, s, {
    attributeFilter: ["style", "class"]
  }), m && V("scroll", s, { capture: !0, passive: !0 }), i && V("resize", s, { passive: !0 }), D(() => {
    a && s();
  }), {
    height: l,
    bottom: c,
    left: v,
    right: f,
    top: d,
    width: u,
    x: o,
    y: r,
    update: s
  };
}
function ve(e, t = { width: 0, height: 0 }, n = {}) {
  const { window: i = O, box: m = "content-box" } = n, a = x(() => {
    var u, o;
    return (o = (u = b(e)) == null ? void 0 : u.namespaceURI) == null ? void 0 : o.includes("svg");
  }), l = g(t.width), c = g(t.height), { stop: v } = U(
    e,
    ([u]) => {
      const o = m === "border-box" ? u.borderBoxSize : m === "content-box" ? u.contentBoxSize : u.devicePixelContentBoxSize;
      if (i && a.value) {
        const r = b(e);
        if (r) {
          const s = i.getComputedStyle(r);
          l.value = Number.parseFloat(s.width), c.value = Number.parseFloat(s.height);
        }
      } else if (o) {
        const r = Array.isArray(o) ? o : [o];
        l.value = r.reduce((s, { inlineSize: h }) => s + h, 0), c.value = r.reduce((s, { blockSize: h }) => s + h, 0);
      } else
        l.value = u.contentRect.width, c.value = u.contentRect.height;
    },
    n
  );
  D(() => {
    const u = b(e);
    u && (l.value = "offsetWidth" in u ? u.offsetWidth : t.width, c.value = "offsetHeight" in u ? u.offsetHeight : t.height);
  });
  const f = W(
    () => b(e),
    (u) => {
      l.value = u ? t.width : 0, c.value = u ? t.height : 0;
    }
  );
  function d() {
    v(), f();
  }
  return {
    width: l,
    height: c,
    stop: d
  };
}
const he = ["data-index"], G = /* @__PURE__ */ Z({
  name: "VirtualWaterfall",
  __name: "virtual-waterfall",
  props: {
    virtual: { type: Boolean, default: !0 },
    rowKey: { default: "id" },
    gap: { default: 15 },
    padding: { default: 15 },
    preloadScreenCount: { default: () => [0, 0] },
    itemMinWidth: { default: 220 },
    maxColumnCount: { default: 10 },
    minColumnCount: { default: 2 },
    items: { default: () => [] },
    calcItemHeight: { type: Function, default: (e, t) => 250 }
  },
  setup(e) {
    const t = e;
    ee();
    const n = g(), { width: i } = ve(n), { top: m } = pe(n);
    I(() => {
      i.value === 0 && (i.value = Number.parseInt(window.getComputedStyle(n.value).width));
    });
    function a(o) {
      return Object.prototype.toString.call(o) === "[object Number]";
    }
    const l = x(() => {
      if (!i.value)
        return 0;
      const o = i.value;
      if (o >= t.itemMinWidth * 2) {
        const r = Math.floor(o / t.itemMinWidth);
        return t.maxColumnCount && r > t.maxColumnCount ? t.maxColumnCount : r;
      }
      return t.minColumnCount;
    }), c = g(new Array(l.value).fill(0)), v = x(() => {
      if (!i.value || l.value <= 0)
        return 0;
      const o = (l.value - 1) * t.gap;
      return Math.ceil((i.value - o) / l.value);
    }), f = g([]);
    te(() => {
      if (!l.value) {
        f.value = [];
        return;
      }
      const o = t.items.length, r = new Array(o);
      let s = 0;
      const h = f.value.length && o > f.value.length;
      h ? s = f.value.length : c.value = new Array(l.value).fill(0);
      for (let p = 0; p < o; p++) {
        if (h && p < s) {
          r[p] = f.value[p];
          continue;
        }
        const w = u(), y = t.calcItemHeight(t.items[p], v.value), C = c.value[w], M = (v.value + t.gap) * w, S = {
          index: p,
          item: t.items[p],
          column: w,
          top: C,
          left: M,
          bottom: C + y,
          height: y
        };
        c.value[w] += y + t.gap, r[p] = S;
      }
      f.value = r;
    });
    const d = x(() => {
      const o = f.value.length;
      if (!o)
        return [];
      if (!t.virtual)
        return f.value;
      const r = n.value.parentElement.offsetTop, s = -m.value + r, [h, p] = t.preloadScreenCount, w = n.value.parentElement.clientHeight, y = s - h * w, C = s + (p + 1) * w, M = [];
      for (let S = 0; S < o; S++) {
        const E = f.value[S], R = E.top, $ = E.bottom;
        (R >= y && R <= C || $ >= y && $ <= C || R < y && $ > C) && M.push(E);
      }
      return M;
    }), u = () => c.value.indexOf(Math.min(...c.value));
    return (o, r) => (k(), z("div", {
      ref_key: "content",
      ref: n,
      style: F({
        position: "relative",
        willChange: "height",
        height: `${Math.max(...c.value)}px`,
        padding: `${a(o.padding) ? o.padding + "px" : o.padding}`
      })
    }, [
      (k(!0), z(ne, null, oe(d.value, (s) => {
        var h;
        return k(), z("div", {
          key: (h = s.item[o.rowKey]) != null ? h : s.index,
          style: F({
            position: "absolute",
            contentVisibility: "auto",
            width: `${v.value}px`,
            height: `${s.height}px`,
            transform: `translate(${s.left}px, ${s.top}px)`,
            containIntrinsicSize: `${v.value}px ${s.height}px`
          }),
          "data-index": s.index
        }, [
          ie(o.$slots, "default", {
            item: s.item,
            index: s.index
          })
        ], 12, he);
      }), 128))
    ], 4));
  }
}), be = {
  install(e) {
    e.component(G.name, G);
  }
};
export {
  G as VirtualWaterfall,
  be as default
};
